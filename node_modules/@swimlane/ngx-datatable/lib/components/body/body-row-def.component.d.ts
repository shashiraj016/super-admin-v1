import { OnInit, TemplateRef, ViewContainerRef } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * This component is passed as ng-template and rendered by BodyComponent.
 * BodyComponent uses rowDefInternal to first inject actual row template.
 * This component will render that actual row template.
 */
export declare class DatatableRowDefComponent {
    rowDef: DatatableRowDefInternalDirective;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableRowDefComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DatatableRowDefComponent, "datatable-row-def", never, {}, {}, never, never, true, never>;
}
export declare class DatatableRowDefDirective {
    static ngTemplateContextGuard(_dir: DatatableRowDefDirective, ctx: unknown): ctx is RowDefContext;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableRowDefDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DatatableRowDefDirective, "[rowDef]", never, {}, {}, never, never, true, never>;
}
/**
 * @internal To be used internally by ngx-datatable.
 */
export declare class DatatableRowDefInternalDirective implements OnInit {
    vc: ViewContainerRef;
    rowDefInternal?: RowDefContext;
    ngOnInit(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableRowDefInternalDirective, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<DatatableRowDefInternalDirective, "[rowDefInternal]", never, { "rowDefInternal": { "alias": "rowDefInternal"; "required": false; }; }, {}, never, never, true, never>;
}
type RowDefContext = {
    template: TemplateRef<unknown>;
    rowTemplate: TemplateRef<unknown>;
    row: any;
    index: number;
};
export {};

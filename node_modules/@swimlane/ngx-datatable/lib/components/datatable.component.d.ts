import { AfterContentInit, AfterViewInit, DoCheck, EventEmitter, KeyValueDiffer, OnDestroy, OnInit, QueryList, TemplateRef } from '@angular/core';
import { DatatableGroupHeaderDirective } from './body/body-group-header.directive';
import { BehaviorSubject, Subscription } from 'rxjs';
import { INgxDatatableConfig } from '../ngx-datatable.module';
import { TableColumn } from '../types/table-column.type';
import { DataTableColumnDirective } from './columns/column.directive';
import { DatatableRowDetailDirective } from './row-detail/row-detail.directive';
import { DatatableFooterDirective } from './footer/footer.directive';
import { DataTableBodyComponent } from './body/body.component';
import { DataTableHeaderComponent } from './header/header.component';
import { ActivateEvent, ColumnMode, ColumnResizeEvent, ContextmenuType, DragEventData, Group, PageEvent, PagerPageEvent, ReorderEvent, RowOrGroup, ScrollEvent, SelectionType, SortEvent, SortPropDir, SortType, TreeStatus } from '../types/public.types';
import * as i0 from "@angular/core";
export declare class DatatableComponent<TRow = any> implements OnInit, DoCheck, AfterViewInit, AfterContentInit, OnDestroy {
    private scrollbarHelper;
    private cd;
    private columnChangesService;
    private configuration;
    /**
     * Template for the target marker of drag target columns.
     */
    targetMarkerTemplate: TemplateRef<unknown>;
    /**
     * Rows that are displayed in the table.
     */
    set rows(val: TRow[] | null | undefined);
    /**
     * Gets the rows.
     */
    get rows(): TRow[];
    /**
     * This attribute allows the user to set the name of the column to group the data with
     */
    set groupRowsBy(val: keyof TRow);
    get groupRowsBy(): keyof TRow;
    /**
     * This attribute allows the user to set a grouped array in the following format:
     *  [
     *    {groupid=1} [
     *      {id=1 name="test1"},
     *      {id=2 name="test2"},
     *      {id=3 name="test3"}
     *    ]},
     *    {groupid=2>[
     *      {id=4 name="test4"},
     *      {id=5 name="test5"},
     *      {id=6 name="test6"}
     *    ]}
     *  ]
     */
    groupedRows: Group<TRow>[];
    /**
     * Columns to be displayed.
     */
    set columns(val: TableColumn[]);
    /**
     * Get the columns.
     */
    get columns(): TableColumn[];
    /**
     * List of row objects that should be
     * represented as selected in the grid.
     * Default value: `[]`
     */
    selected: TRow[];
    /**
     * Enable vertical scrollbars
     */
    scrollbarV: boolean;
    /**
     * Enable vertical scrollbars dynamically on demand.
     * Property `scrollbarV` needs to be set `true` too.
     * Width that is gained when no scrollbar is needed
     * is added to the inner table width.
     */
    scrollbarVDynamic: boolean;
    /**
     * Enable horz scrollbars
     */
    scrollbarH: boolean;
    /**
     * The row height; which is necessary
     * to calculate the height for the lazy rendering.
     */
    rowHeight: number | 'auto' | ((row?: TRow) => number);
    /**
     * Type of column width distribution formula.
     * Example: flex, force, standard
     */
    columnMode: ColumnMode | keyof typeof ColumnMode;
    /**
     * The minimum header height in pixels.
     * Pass a falsey for no header
     */
    headerHeight: number;
    /**
     * The minimum footer height in pixels.
     * Pass falsey for no footer
     */
    footerHeight: number;
    /**
     * If the table should use external paging
     * otherwise its assumed that all data is preloaded.
     */
    externalPaging: boolean;
    /**
     * If the table should use external sorting or
     * the built-in basic sorting.
     */
    externalSorting: boolean;
    /**
     * The page size to be shown.
     * Default value: `undefined`
     */
    set limit(val: number | undefined);
    /**
     * Gets the limit.
     */
    get limit(): number | undefined;
    /**
     * The total count of all rows.
     * Default value: `0`
     */
    set count(val: number);
    /**
     * Gets the count.
     */
    get count(): number;
    /**
     * The current offset ( page - 1 ) shown.
     * Default value: `0`
     */
    set offset(val: number);
    get offset(): number;
    /**
     * Show the linear loading bar.
     * Default value: `false`
     */
    loadingIndicator: boolean;
    /**
     * Show ghost loaders on each cell.
     * Default value: `false`
     */
    set ghostLoadingIndicator(val: boolean);
    get ghostLoadingIndicator(): boolean;
    /**
     * Type of row selection. Options are:
     *
     *  - `single`
     *  - `multi`
     *  - `checkbox`
     *  - `multiClick`
     *  - `cell`
     *
     * For no selection pass a `falsey`.
     * Default value: `undefined`
     */
    selectionType: SelectionType;
    /**
     * Enable/Disable ability to re-order columns
     * by dragging them.
     */
    reorderable: boolean;
    /**
     * Swap columns on re-order columns or
     * move them.
     */
    swapColumns: boolean;
    /**
     * The type of sorting
     */
    sortType: SortType;
    /**
     * Array of sorted columns by property and type.
     * Default value: `[]`
     */
    sorts: SortPropDir[];
    /**
     * Css class overrides
     */
    cssClasses: Partial<INgxDatatableConfig['cssClasses']>;
    /**
     * Message overrides for localization
     *
     * emptyMessage     [default] = 'No data to display'
     * totalMessage     [default] = 'total'
     * selectedMessage  [default] = 'selected'
     */
    messages: Partial<INgxDatatableConfig['messages']>;
    /**
     * A function which is called with the row and should return either:
     * - a string: `"class-1 class-2`
     * - a Record<string, boolean>: `{ 'class-1': true, 'class-2': false }`
     */
    rowClass: (row: Group<TRow> | TRow) => string | Record<string, boolean>;
    /**
     * A boolean/function you can use to check whether you want
     * to select a particular row based on a criteria. Example:
     *
     *    (selection) => {
     *      return selection !== 'Ethel Price';
     *    }
     */
    selectCheck: (value: TRow, index: number, array: TRow[]) => boolean;
    /**
     * A function you can use to check whether you want
     * to show the checkbox for a particular row based on a criteria. Example:
     *
     *    (row, column, value) => {
     *      return row.name !== 'Ethel Price';
     *    }
     */
    displayCheck: (row: TRow, column: TableColumn, value?: any) => boolean;
    /**
     * A boolean you can use to set the detault behaviour of rows and groups
     * whether they will start expanded or not. If ommited the default is NOT expanded.
     *
     */
    groupExpansionDefault: boolean;
    /**
     * Property to which you can use for custom tracking of rows.
     * Example: 'name'
     */
    trackByProp: string;
    /**
     * Property to which you can use for determining select all
     * rows on current page or not.
     */
    selectAllRowsOnPage: boolean;
    /**
     * A flag for row virtualization on / off
     */
    virtualization: boolean;
    /**
     * Tree from relation
     */
    treeFromRelation: string;
    /**
     * Tree to relation
     */
    treeToRelation: string;
    /**
     * A flag for switching summary row on / off
     */
    summaryRow: boolean;
    /**
     * A height of summary row
     */
    summaryHeight: number;
    /**
     * A property holds a summary row position: top/bottom
     */
    summaryPosition: string;
    /**
     * A function you can use to check whether you want
     * to disable a row. Example:
     *
     *    (row) => {
     *      return row.name !== 'Ethel Price';
     *    }
     */
    disableRowCheck: (row: TRow) => boolean;
    /**
     * A flag to enable drag behavior of native HTML5 drag and drop API on rows.
     * If set to true, {@link rowDragEvents} will emit dragstart and dragend events.
     */
    rowDraggable: boolean;
    /**
     * A flag to controll behavior of sort states.
     * By default sort on column toggles between ascending and descending without getting removed.
     * Set true to clear sorting of column after performing ascending and descending sort on that column.
     */
    enableClearingSortState: boolean;
    /**
     * Body was scrolled typically in a `scrollbarV:true` scenario.
     */
    scroll: EventEmitter<ScrollEvent>;
    /**
     * A cell or row was focused via keyboard or mouse click.
     */
    activate: EventEmitter<ActivateEvent<TRow>>;
    /**
     * A cell or row was selected.
     */
    select: EventEmitter<{
        selected: TRow[];
    }>;
    /**
     * Column sort was invoked.
     */
    sort: EventEmitter<SortEvent>;
    /**
     * The table was paged either triggered by the pager or the body scroll.
     */
    page: EventEmitter<PageEvent>;
    /**
     * Columns were re-ordered.
     */
    reorder: EventEmitter<ReorderEvent>;
    /**
     * Column was resized.
     */
    resize: EventEmitter<ColumnResizeEvent>;
    /**
     * The context menu was invoked on the table.
     * type indicates whether the header or the body was clicked.
     * content contains either the column or the row that was clicked.
     */
    tableContextmenu: EventEmitter<{
        event: MouseEvent;
        type: ContextmenuType;
        content: TableColumn | RowOrGroup<TRow>;
    }>;
    /**
     * A row was expanded ot collapsed for tree
     */
    treeAction: EventEmitter<{
        row: TRow;
        rowIndex: number;
    }>;
    /**
     * Emits HTML5 native drag events.
     * Only emits dragenter, dragover, drop events by default.
     * Set {@link rowDraggble} to true for dragstart and dragend.
     */
    rowDragEvents: EventEmitter<DragEventData>;
    /**
     * CSS class applied if the header height if fixed height.
     */
    get isFixedHeader(): boolean;
    /**
     * CSS class applied to the root element if
     * the row heights are fixed heights.
     */
    get isFixedRow(): boolean;
    /**
     * CSS class applied to root element if
     * vertical scrolling is enabled.
     */
    get isVertScroll(): boolean;
    /**
     * CSS class applied to root element if
     * virtualization is enabled.
     */
    get isVirtualized(): boolean;
    /**
     * CSS class applied to the root element
     * if the horziontal scrolling is enabled.
     */
    get isHorScroll(): boolean;
    /**
     * CSS class applied to root element is selectable.
     */
    get isSelectable(): boolean;
    /**
     * CSS class applied to root is checkbox selection.
     */
    get isCheckboxSelection(): boolean;
    /**
     * CSS class applied to root if cell selection.
     */
    get isCellSelection(): boolean;
    /**
     * CSS class applied to root if single select.
     */
    get isSingleSelection(): boolean;
    /**
     * CSS class added to root element if mulit select
     */
    get isMultiSelection(): boolean;
    /**
     * CSS class added to root element if mulit click select
     */
    get isMultiClickSelection(): boolean;
    /**
     * Column templates gathered from `ContentChildren`
     * if described in your markup.
     */
    columnTemplates: QueryList<DataTableColumnDirective<TRow>>;
    /**
     * Row Detail templates gathered from the ContentChild
     */
    rowDetail: DatatableRowDetailDirective;
    /**
     * Group Header templates gathered from the ContentChild
     */
    groupHeader: DatatableGroupHeaderDirective;
    /**
     * Footer template gathered from the ContentChild
     */
    footer: DatatableFooterDirective;
    /**
     * Reference to the body component for manually
     * invoking functions on the body.
     */
    bodyComponent: DataTableBodyComponent<TRow & {
        treeStatus?: TreeStatus;
    }>;
    /**
     * Reference to the header component for manually
     * invoking functions on the header.
     */
    headerComponent: DataTableHeaderComponent;
    private bodyElement;
    rowDefTemplate?: TemplateRef<any>;
    /**
     * Returns if all rows are selected.
     */
    get allRowsSelected(): boolean;
    element: HTMLElement;
    rowDiffer: KeyValueDiffer<TRow, TRow>;
    _innerWidth: number;
    pageSize: number;
    bodyHeight: number;
    rowCount: number;
    _offsetX: BehaviorSubject<number>;
    _limit: number | undefined;
    _count: number;
    _offset: number;
    _rows: TRow[] | null | undefined;
    _groupRowsBy: keyof TRow;
    _internalRows: TRow[];
    _internalColumns: TableColumn[];
    _columns: TableColumn[];
    _subscriptions: Subscription[];
    _ghostLoadingIndicator: boolean;
    _defaultColumnWidth?: number;
    protected verticalScrollVisible: boolean;
    private _rowInitDone;
    constructor();
    /**
     * Lifecycle hook that is called after data-bound
     * properties of a directive are initialized.
     */
    ngOnInit(): void;
    /**
     * Lifecycle hook that is called after a component's
     * view has been fully initialized.
     */
    ngAfterViewInit(): void;
    /**
     * Lifecycle hook that is called after a component's
     * content has been fully initialized.
     */
    ngAfterContentInit(): void;
    /**
     * This will be used when displaying or selecting rows.
     * when tracking/comparing them, we'll use the value of this fn,
     *
     * (`fn(x) === fn(y)` instead of `x === y`)
     */
    rowIdentity: (x: TRow | Group<TRow>) => unknown;
    /**
     * Translates the templates to the column objects
     */
    translateColumns(val: QueryList<DataTableColumnDirective<TRow>>): void;
    /**
     * Creates a map with the data grouped by the user choice of grouping index
     *
     * @param originalArray the original array passed via parameter
     * @param groupBy the key of the column to group the data by
     */
    groupArrayBy(originalArray: TRow[], groupBy: keyof TRow): {
        key: TRow[keyof TRow];
        value: TRow[];
    }[];
    ngDoCheck(): void;
    /**
     * Recalc's the sizes of the grid.
     *
     * Updated automatically on changes to:
     *
     *  - Columns
     *  - Rows
     *  - Paging related
     *
     * Also can be manually invoked or upon window resize.
     */
    recalculate(): void;
    /**
     * Window resize handler to update sizes.
     */
    onWindowResize(): void;
    /**
     * Recalulcates the column widths based on column width
     * distribution mode and scrollbar offsets.
     */
    recalculateColumns(columns?: TableColumn[], forceIdx?: number, allowBleed?: boolean): TableColumn[] | undefined;
    /**
     * Recalculates the dimensions of the table size.
     * Internally calls the page size and row count calcs too.
     *
     */
    recalculateDims(): void;
    /**
     * Recalculates the pages after a update.
     */
    recalculatePages(): void;
    /**
     * Body triggered a page event.
     */
    onBodyPage(offset: number): void;
    /**
     * The body triggered a scroll event.
     */
    onBodyScroll(event: ScrollEvent): void;
    /**
     * The footer triggered a page event.
     */
    onFooterPage(event: PagerPageEvent): void;
    /**
     * Recalculates the sizes of the page
     */
    calcPageSize(): number;
    /**
     * Calculates the row count.
     */
    calcRowCount(): number;
    /**
     * The header triggered a contextmenu event.
     */
    onColumnContextmenu({ event, column }: {
        event: MouseEvent;
        column: TableColumn;
    }): void;
    /**
     * The body triggered a contextmenu event.
     */
    onRowContextmenu({ event, row }: {
        event: MouseEvent;
        row: RowOrGroup<TRow>;
    }): void;
    /**
     * The header triggered a column resize event.
     */
    onColumnResize({ column, newValue, prevValue }: ColumnResizeEvent): void;
    onColumnResizing({ column, newValue }: ColumnResizeEvent): void;
    /**
     * The header triggered a column re-order event.
     */
    onColumnReorder({ column, newValue, prevValue }: ReorderEvent): void;
    /**
     * The header triggered a column sort event.
     */
    onColumnSort(event: SortEvent): void;
    /**
     * Toggle all row selection
     */
    onHeaderSelect(): void;
    /**
     * A row was selected from body
     */
    onBodySelect(event: {
        selected: TRow[];
    }): void;
    /**
     * A row was expanded or collapsed for tree
     */
    onTreeAction(event: {
        row: TRow;
    }): void;
    ngOnDestroy(): void;
    /**
     * listen for changes to input bindings of all DataTableColumnDirective and
     * trigger the columnTemplates.changes observable to emit
     */
    private listenForColumnInputChanges;
    private sortInternalRows;
    static ɵfac: i0.ɵɵFactoryDeclaration<DatatableComponent<any>, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<DatatableComponent<any>, "ngx-datatable", never, { "targetMarkerTemplate": { "alias": "targetMarkerTemplate"; "required": false; }; "rows": { "alias": "rows"; "required": false; }; "groupRowsBy": { "alias": "groupRowsBy"; "required": false; }; "groupedRows": { "alias": "groupedRows"; "required": false; }; "columns": { "alias": "columns"; "required": false; }; "selected": { "alias": "selected"; "required": false; }; "scrollbarV": { "alias": "scrollbarV"; "required": false; }; "scrollbarVDynamic": { "alias": "scrollbarVDynamic"; "required": false; }; "scrollbarH": { "alias": "scrollbarH"; "required": false; }; "rowHeight": { "alias": "rowHeight"; "required": false; }; "columnMode": { "alias": "columnMode"; "required": false; }; "headerHeight": { "alias": "headerHeight"; "required": false; }; "footerHeight": { "alias": "footerHeight"; "required": false; }; "externalPaging": { "alias": "externalPaging"; "required": false; }; "externalSorting": { "alias": "externalSorting"; "required": false; }; "limit": { "alias": "limit"; "required": false; }; "count": { "alias": "count"; "required": false; }; "offset": { "alias": "offset"; "required": false; }; "loadingIndicator": { "alias": "loadingIndicator"; "required": false; }; "ghostLoadingIndicator": { "alias": "ghostLoadingIndicator"; "required": false; }; "selectionType": { "alias": "selectionType"; "required": false; }; "reorderable": { "alias": "reorderable"; "required": false; }; "swapColumns": { "alias": "swapColumns"; "required": false; }; "sortType": { "alias": "sortType"; "required": false; }; "sorts": { "alias": "sorts"; "required": false; }; "cssClasses": { "alias": "cssClasses"; "required": false; }; "messages": { "alias": "messages"; "required": false; }; "rowClass": { "alias": "rowClass"; "required": false; }; "selectCheck": { "alias": "selectCheck"; "required": false; }; "displayCheck": { "alias": "displayCheck"; "required": false; }; "groupExpansionDefault": { "alias": "groupExpansionDefault"; "required": false; }; "trackByProp": { "alias": "trackByProp"; "required": false; }; "selectAllRowsOnPage": { "alias": "selectAllRowsOnPage"; "required": false; }; "virtualization": { "alias": "virtualization"; "required": false; }; "treeFromRelation": { "alias": "treeFromRelation"; "required": false; }; "treeToRelation": { "alias": "treeToRelation"; "required": false; }; "summaryRow": { "alias": "summaryRow"; "required": false; }; "summaryHeight": { "alias": "summaryHeight"; "required": false; }; "summaryPosition": { "alias": "summaryPosition"; "required": false; }; "disableRowCheck": { "alias": "disableRowCheck"; "required": false; }; "rowDraggable": { "alias": "rowDraggable"; "required": false; }; "enableClearingSortState": { "alias": "enableClearingSortState"; "required": false; }; "rowIdentity": { "alias": "rowIdentity"; "required": false; }; }, { "scroll": "scroll"; "activate": "activate"; "select": "select"; "sort": "sort"; "page": "page"; "reorder": "reorder"; "resize": "resize"; "tableContextmenu": "tableContextmenu"; "treeAction": "treeAction"; "rowDragEvents": "rowDragEvents"; }, ["rowDetail", "groupHeader", "footer", "rowDefTemplate", "columnTemplates"], ["[loading-indicator]", "[empty-content]"], true, never>;
    static ngAcceptInputType_scrollbarV: unknown;
    static ngAcceptInputType_scrollbarVDynamic: unknown;
    static ngAcceptInputType_scrollbarH: unknown;
    static ngAcceptInputType_headerHeight: unknown;
    static ngAcceptInputType_footerHeight: unknown;
    static ngAcceptInputType_externalPaging: unknown;
    static ngAcceptInputType_externalSorting: unknown;
    static ngAcceptInputType_limit: unknown;
    static ngAcceptInputType_count: unknown;
    static ngAcceptInputType_offset: unknown;
    static ngAcceptInputType_loadingIndicator: unknown;
    static ngAcceptInputType_ghostLoadingIndicator: unknown;
    static ngAcceptInputType_reorderable: unknown;
    static ngAcceptInputType_swapColumns: unknown;
    static ngAcceptInputType_groupExpansionDefault: unknown;
    static ngAcceptInputType_selectAllRowsOnPage: unknown;
    static ngAcceptInputType_virtualization: unknown;
    static ngAcceptInputType_summaryRow: unknown;
    static ngAcceptInputType_summaryHeight: unknown;
    static ngAcceptInputType_rowDraggable: unknown;
    static ngAcceptInputType_enableClearingSortState: unknown;
}
